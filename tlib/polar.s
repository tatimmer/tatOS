;tatOS/tlib/polar.s


;polar2rect, fillsincos, rad2deg, normalizedeg


;**********************************************
;polar2rect
;polar to cartesian conversion 
;this function uses the prebuilt SINTABLE & COSTABLE
;lookup tables are generated by "FillSinCos" below

;input
;push radius,pixels                 [ebp+12]
;push theta,degrees (0,1,2...359)   [ebp+8]

;return
;ebx=dX=Rcos(theta) 
;eax=dY=Rsin(theta)

;ebx and eax are signed integer values
;ZF is clear on error
;**********************************************

polar2rect:

    push ebp
	mov ebp,esp
	push ecx
	push edx
	push edi


	;ecx=degree=index into dword table
	mov ecx,[ebp+8]


	;angle must be 0-359 deg
	;because its an index into our lookup tables
	cmp ecx,360
	jb .setedi
	mov eax,ecx
	add eax,360
	xor edx,edx
	mov ebx,360
	div ebx
	mov ecx,edx
	

.setedi:
	;ebx=radius
	mov edi,[ebp+12]


	;work on dX
	mov eax,[COSTABLE+ecx*4]
	imul edi 	;eax=R*cos(theta)
	

	;to avoid a costly idiv by 2^16=65536
	;we use Agner Fog's alternative
	;for signed division by 2^N
	;see Agners Pentium Optimization Manual
	;idiv esi    ;eax=R*cos(theta)/65536
	cdq
	shr edx,16   ;shift by 32-N
	add eax,edx
	sar eax,16   ;shift by N
	mov ebx,eax  ;ebx=X=R*cos(theta)/65536


	;work on dY
	mov eax,[SINTABLE+ecx*4]
	imul edi
	cdq
	shr edx,16   ;shift by 32-N
	add eax,edx
	sar eax,16   ;shift by N


	;set zf on success
	xor edx,edx

	
.done:
	pop edi
	pop edx
	pop ecx
	pop ebp
	retn 8




;********************************************************
;fillsincos
;we loop 360 times incrementing by 1 deg each time
;fills dword arrays sintable[] and costable[]
;each array holds 360 dwords = 1440 bytes
;each entry is scaled by 2^16 = 65536 to make a signed integer
;1st entry of cos table: 65536 * cos(0deg)
;2nd entry of cos table: 65536 * cos(1deg)
;3rd entry of cos table: 65536 * cos(3deg)
;and so on ... ditto for sin table
;so after retrieving a value from the table and doing
;signed imul by amplitude you should do signed divide by 65536
;use "sar" arithmetic right shift by 16 instead of the division 
;this function is called on startup in boot2.s
;see tatos/doc/memorymap and tatos/tlib/tatos.inc
;where we reserve memory for SINTABLE and COSTABLE

;local variables
_radsperdeg:
dq 0.01745329

_multiplier:
dd 65536

;********************************************************
fillsincos:

	mov ecx,360
	mov esi,SINTABLE
	mov edi,COSTABLE

	;.01745 is our angle increment
	fld qword [_radsperdeg]
	;st0=.01745

	fldz
	;st0=angle_start, st1=.01745


.SinCosLoop:

	;copy st0->st2
	fst st2
	;st0=angle, st1=.01745, st2=angle
	
	fsincos
	;st0=cos(st0), st1=sin(st0), st2=.01745, st3=angle

	fimul dword [_multiplier]
	;st0=65536*cos(st0), st1=sin(st0), st2=.01745, st3=angle

	;save st0->costable
	fistp dword [edi]
	;st1=sin(st0), st2=.01745, st3=angle

	fimul dword [_multiplier]
	;st0=65536*sin(st0), st1=.01745, st2=angle

	;save st0->sintable
	fistp dword [esi]
	;st0=.01745, st1=angle


	;inc pointers to sintable and costable
	add esi,4
	add edi,4

	fxch st1
	;st0=angle, st1=.01756

	fadd st1
	;st0=angle+angleinc, st1=.01745

	loop .SinCosLoop

	ffree st0
	ffree st1

	ret


    




;**********************************************
;rad2deg
;converts the qword radian value in st0
;to degrees in st0

;input:
;st0=angle value in radians

;return:
;st0=angle value in degrees

;the function qtod may be used to convert
;the deg float to int for using the polar
;lookup tables. The conversion constant is
;defined in tlib.s
;**********************************************

rad2deg:
	fmul qword [one_eighty_over_pi]
	ret




;**********************************************
;normalizedeg
;converts a signed integer degree value
;to an unsigned value in the range of 0-359

;input
;eax=degree value to manipulate

;return
;eax=degree value in range 0-359
;************************************************

normalizedeg:

	push edx
	push ebx

	;we assume the value is bigger than -720
	add eax,720
	xor edx,edx
	mov ebx,360
	div ebx
	;value in edx is in range 0-359
	mov eax,edx

	pop ebx
	pop edx
	ret
	


